////////////////////////////////////////////////////////////////////////////////
// Клиентские и серверные процедуры общего назначения но не из БСП
// Работа с XDTO

// Функция - Создать объект XDTO
//
// Параметры:
//  Тип					 - Строка - Требуемый тип
//  Значение			 - Произвольное - Значение на базе которого нужно создать объект 
//  URLПространстваИмен	 - Строка - Пространство имен по умолчанию http://www.w3.org/2001/XMLSchema
//  Фабрика				 - ФабрикаXDTO	 - Используемая фабрика по умолчанию фабрика текщей конфигурации
// 
// Возвращаемое значение:
//  ОбъектXDTO - Созданный объект
//
функция СоздатьОбъектXDTO(Тип, Значение = Неопределено, URLПространстваИмен = Неопределено,Фабрика = Неопределено) Экспорт 
	
	Если URLПространстваИмен = Неопределено Тогда 
		URLПространстваИмен = "http://www.w3.org/2001/XMLSchema";
	КонецЕсли;
	
	Если Фабрика = Неопределено Тогда 
		#Если ВебКлиент Тогда
			Возврат Неопределено;
		#Иначе	
			Фабрика = ФабрикаXDTO;
		#КонецЕсли 
	КонецЕсли;	
	
	Возврат Фабрика.Создать(Фабрика.Тип(URLПространстваИмен,Тип), Значение);
	
КонецФункции	

// Функция - Получить значение XDTO
//
// Параметры:
//  ОбъектXDTO			 - ОбъектXDTO - Объект XDTO из которого брать данные 
//  ПутьКЭлементу			 - Строка - путь к нужным данным (с разделением через точку)
//  ЗначениеПоУмолчанию	 - Произвольный - что вернуть если нет нужных данных
// 
// Возвращаемое значение:
//  произвольный - запрашиваемые данные или ЗначениеПоУмолчанию
//
Функция ПолучитьЗначениеXDTO(ОбъектXDTO, ПутьКЭлементу, ЗначениеПоУмолчанию = Неопределено) Экспорт
	
	Если Не ОбъектСодержитСвойствоXDTO(ОбъектXDTO, ПутьКЭлементу) Тогда 
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
	МассивПути = СтрРазделить(ПутьКЭлементу,".");
	ДочернийОбъектXDTO = ОбъектXDTO;
	Для Каждого ЧастьПути из МассивПути Цикл 
		ДочернийОбъектXDTO = ДочернийОбъектXDTO[ЧастьПути];
	КонецЦикла;	
	
	Возврат ДочернийОбъектXDTO;
	
КонецФункции	

// Функция - Получить значение списка XDTO
// Получает список XDTO из Объекта XDTO и преобразует его в массив (что позволяет нормально обходить его в цикле) 
//
// Параметры:
//  ОбъектXDTO		- ОбъектXDTO - Объект XDTO из которого брать данные 
//  ПутьКЭлементу	- Строка - Путь к нужному списку в ОбъектXDTO 
// 
// Возвращаемое значение:
//  Массив - содержимое списка XDTO  
//
Функция ПолучитьЗначениеСпискаXDTO(ОбъектXDTO, ПутьКЭлементу) Экспорт
	
	СписокXDTO =  ПолучитьЗначениеXDTO(ОбъектXDTO, ПутьКЭлементу, Неопределено);
	
	Если СписокXDTO = Неопределено Тогда 
		
		Возврат Новый Массив;
		
	ИначеЕсли  ТипЗнч(СписокXDTO) = Тип("СписокXDTO") Тогда 
		
		Результат = Новый Массив;
		
		Для Каждого ОбъектСпискаXDTO из СписокXDTO Цикл 
			Результат.Добавить(ОбъектСпискаXDTO);
		КонецЦикла;	
		
		Возврат Результат;
		
	Иначе 
		
		Возврат ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(СписокXDTO); //в списке одно значение и он представляется как объект
		
	КонецЕсли;	
	
КонецФункции	

// Функция - Объект содержит свойство XDTO
//
// Параметры:
//  ОбъектXDTO	 - ОбъектXDTO - Объект XDTO из которого брать данные
//  ПутьКЭлементу	 - Строка - путь к проверяемым данным 
// 
// Возвращаемое значение:
//  Булево - есть или нет заправшиваемый путь 
//
функция ОбъектСодержитСвойствоXDTO(ОбъектXDTO, ПутьКЭлементу) Экспорт
	
	Если ТипЗнч(ОбъектXDTO) <> Тип("ОбъектXDTO") Тогда 
		Возврат Ложь;
	КонецЕсли;	
	
	Если  СтрНайти(ПутьКЭлементу,".") = 0 Тогда 
		Возврат ОбъектXDTO.Свойства().Получить(ПутьКЭлементу) <> Неопределено;
	Иначе 
		
		МассивПути = СтрРазделить(ПутьКЭлементу,".");
		ПервоеСвойство = МассивПути[0];
		
		Если ОбъектXDTO.Свойства().Получить(ПервоеСвойство) = Неопределено Тогда 
			Возврат Ложь;
			
		Иначе 
			ДочернийОбъектXDTO = ОбъектXDTO[ПервоеСвойство];
			МассивПути.Удалить(0);
			ДочернийПуть = СтрСоединить(МассивПути,".");
			
			Возврат ОбъектСодержитСвойствоXDTO(ДочернийОбъектXDTO, ДочернийПуть);
			
		КонецЕсли;	
		
	КонецЕсли;
	
КонецФункции	

// Функция - Список XDTO найти строки
//  Аналог найти строки из таблицы значений для списков XDTO
//
// Параметры:
//  ОбъектXDTO		 - ОбъектXDTO	 - Объект XDTO из которого брать данные
//  ПутьКЭлементу	 - Строка		 - Путь к нужному списку в ОбъектXDTO
//  СтруктураПоиска	 - Структура	 - Условия поиска
// 
// Возвращаемое значение:
//  Массив - Найденные значения
//
Функция СписокXDTOНайтиСтроки(ОбъектXDTO, ПутьКЭлементу, СтруктураПоиска) Экспорт 
	
	Результат = Новый Массив;
	
	СписокXDTO = ПолучитьЗначениеСпискаXDTO(ОбъектXDTO, ПутьКЭлементу);
	Для Каждого ЭлементСпискаXDTO Из СписокXDTO Цикл 
		Подходит = Истина;
		
		Для Каждого ЭлементСтруктуры из СтруктураПоиска Цикл 
			
			Если  ПолучитьЗначениеXDTO(ЭлементСпискаXDTO, ЭлементСтруктуры.Ключ) = ЭлементСтруктуры.Значение Тогда 
				Продолжить;
			КонецЕсли;
			
			Подходит = Ложь;
			Прервать;			
			
		КонецЦикла;	
		
		Если Подходит Тогда 
			Результат.Добавить(ЭлементСпискаXDTO);
		КонецЕсли;
		
	КонецЦикла;	
	
	Возврат Результат;
	
	
КонецФункции	

// Работа с XDTO
////////////////////////////////////////////////////////////////////////////////
// Более компактный вариант описания типов с квалификатором  

Функция ОписаниеТипаСтрока(Длина = 0, Знач ДопустимаяДлина = Неопределено) Экспорт 
	Если ДопустимаяДлина = Неопределено Тогда 
		ДопустимаяДлина = ПредопределенноеЗначение("ДопустимаяДлина.Переменная");
	КонецЕсли; 
	
	Возврат Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(Длина, ДопустимаяДлина));
	
КонецФункции	

Функция ОписаниеТипаДвоичныеДанные(Длина = 0, Знач ДопустимаяДлина = Неопределено) Экспорт 
	Если ДопустимаяДлина = Неопределено Тогда 
		ДопустимаяДлина = ПредопределенноеЗначение("ДопустимаяДлина.Переменная");
	КонецЕсли; 
	
	
	Возврат Новый ОписаниеТипов("ДвоичныеДанные", ,,, Новый КвалификаторыДвоичныхДанных(Длина, ДопустимаяДлина));
	
КонецФункции	

Функция ОписаниеТипаДата(ЧастиДаты = Неопределено) Экспорт 
	Если ЧастиДаты = Неопределено Тогда 
		ЧастиДаты = ПредопределенноеЗначение("ЧастиДаты.ДатаВремя");
	КонецЕсли; 
	
	Возврат Новый ОписаниеТипов("Дата",,, Новый КвалификаторыДаты(ЧастиДаты));
	
КонецФункции	

Функция ОписаниеТипаЧисло(ЧислоРазрядов = 10, ЧислоРазрядовДробнойЧасти = 0, Знач ДопустимыйЗнак = Неопределено) Экспорт 
	
	Если ДопустимыйЗнак = Неопределено Тогда 
		ДопустимыйЗнак = ПредопределенноеЗначение("ДопустимыйЗнак.Любой");
	КонецЕсли; 
	
	Возврат Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(ЧислоРазрядов, ЧислоРазрядовДробнойЧасти, ДопустимыйЗнак));
	
КонецФункции	

// Более компактный вариант описания типов с квалификатором 
////////////////////////////////////////////////////////////////////////////////

// Функция - Удалить строки из таблицы
//
// Параметры:
//  Таблица	 - ТаблицаЗначений	 - Таблица где нужно удалить строки
//  Строки	 - Массив, Структура - Массив строки таблицы для удаления.
//  Структура условий поиска строк в таблице(см НайтиСтроки()).
// 
// Возвращаемое значение:
//  Булево - флаг сигнализирующий о том что были фактичестки удалены строки (возможно ложь если по отборам нет строк для удаления) 
//
Функция УдалитьСтрокиИзТаблицы(Таблица, Строки) Экспорт 
	
	Если ТипЗнч(Строки) = Тип("Структура") Тогда 
		МассивСтрок = Таблица.НайтиСтроки(Строки); 
	Иначе 
		МассивСтрок = Строки;
	КонецЕсли;	
	
	Результат = Ложь;
	
	Для Каждого СтрокаДляУдаления из МассивСтрок Цикл
		Таблица.Удалить(СтрокаДляУдаления);
		Результат = Истина;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции	

// Функция - Заполнить строку таблицы
//
// Параметры:
//  СтрокаТаблицы	 - СтрокаТаблицыЗначений - Эту строку будем заполнять
//  Значение0		 - Произвольный - 
//  Значение1		 - Произвольный - 
//  Значение2		 - Произвольный - 
//  Значение3		 - Произвольный - 
//  Значение4		 - Произвольный - 
//  Значение5		 - Произвольный - 
//  Значение6		 - Произвольный - 
//  Значение7		 - Произвольный - 
//  Значение8		 - Произвольный - 
//  Значение9		 - Произвольный - 
// 
// Возвращаемое значение:
//  СтрокаТаблицыЗначений - строка из параметра СтрокаТаблицы
//
функция ЗаполнитьСтрокуТаблицы(СтрокаТаблицы, Значение0 = Неопределено, Значение1 = Неопределено, Значение2 = Неопределено, Значение3 = Неопределено, Значение4 = Неопределено, Значение5 = Неопределено, Значение6 = Неопределено, Значение7 = Неопределено, Значение8 = Неопределено, Значение9 = Неопределено) Экспорт 
	
	Колонки = СтрокаТаблицы.Владелец().Колонки; 
	
	Для Каждого Колонка из Колонки Цикл 
		ИндексКолонки = Колонки.Индекс(Колонка);
		ЗначениеПоля = Вычислить("Значение"+ИндексКолонки);
		
		СтрокаТаблицы[Колонка.Имя] = ЗначениеПоля;
		
	КонецЦикла;	
	
	Возврат СтрокаТаблицы;
	
КонецФункции


// Функция - Получить реквизит или свойство объекта если у обекта есть соответствующее свойство или реквизит
//
// Параметры:
//  Объект				 - произвольный - объект источник 
//  ИмяРеквизита		 - строка - имя реквизита получаемого у объекта
//  ЗначениеПоУмолчанию	 - произвольный - значение возвращаемое в случае отсутствия реквизита
// 
// Возвращаемое значение:
//  произвольный - значение реквизита или ЗначениеПоУмолчанию
//
Функция ПолучитьРеквизитИлиСвойствоОбъектаЕслиЕсть(Объект, ИмяРеквизита, ЗначениеПоУмолчанию = Неопределено) Экспорт
	
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Объект, ИмяРеквизита) Тогда 
		Возврат Объект[ИмяРеквизита]; 
	Иначе 
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;	
	
КонецФункции	

Функция МассивСтруктурНайти(Массив, Значение, ИменаПолей="") Экспорт 
	
	МассивИменПолей = СтрРазделить(ИменаПолей,",");
	
	
	Для Каждого СтрокаМассива из Массив Цикл 
		
		Для Каждого ЗнчениеПоля из СтрокаМассива Цикл 
			Если ЗначениеЗаполнено(МассивИменПолей) и МассивИменПолей.Найти(ЗнчениеПоля.Ключ) = Неопределено Тогда 
				Продолжить;	
			КонецЕсли;
			
			Если ЗнчениеПоля.Значение <> Значение Тогда
				Продолжить;
			КонецЕсли;	
			
			Возврат СтрокаМассива;
			
		КонецЦикла;	
		
	КонецЦикла;
	
	Возврат Неопределено
	
КонецФункции

// Получает строку, содержащую ключи структуры, разделенные символом разделителя.
//
// Параметры:
//	Структура - Структура - Структура, ключи которой преобразуются в строку.
//	Разделитель - Строка - Разделитель, который вставляется в строку между ключами структуры.
//
// Возвращаемое значение:
//	Строка - Строка, содержащая ключи структуры разделенные разделителем.
//
Функция КлючиСтруктурыВСтроку(Структура, Разделитель = ",") Экспорт 
	
	Результат = Новый Массив;
	
	Для Каждого ЭлементСтруктуры из Структура Цикл
		
		Результат.Добавить(ЭлементСтруктуры.Ключ);
		
	КонецЦикла;	
	
	Возврат СтрСоединить(Результат, ",");
	
КонецФункции	

// Функция - Получить первопричину ошибки
//
// Параметры:
//  ИнформацияОбОшибке	 - ИнформацияОбОшибке - информация об ошибке откуда нужно извлечь первопричину
// 
// Возвращаемое значение:
//  Строка - Исходный текст ошибки (то что было написано после ВызватьИсключение) 
//
Функция ПолучитьПервопричинуОшибки(ИнформацияОбОшибке) Экспорт 
	
	Если ИнформацияОбОшибке.Причина = Неопределено Тогда 
		Возврат ИнформацияОбОшибке.Описание;
	Иначе 
		Возврат ПолучитьПервопричинуОшибки(ИнформацияОбОшибке.Причина);
	КонецЕсли;	
	
КонецФункции
